COMMITED PROJECT - YOUR PROFESSIONAL DEVELOPMENT FRAMEWORK
================================================================

PROJECT NAME: CommitEd
ARCHITECTURE: Microservices (Separate Repository Per Service)
TEAM: Student developers learning professional practices

================================================================
  IMPORTANT: SERVICES ARE EXAMPLES
================================================================

The services mentioned below (auth, user, project, notification, api-gateway)
are EXAMPLES of what your microservices might be called.

Your actual services may be named differently. Replace these example names 
with your real service names in all guides.

These guides use consistent example names to help explain concepts.

================================================================
  REPOSITORY STRUCTURE
================================================================

Each service is its own GitHub repository:

CommitEd Project Structure:
  CommitEd-auth-service           <- Separate GitHub repo
  CommitEd-user-service           <- Separate GitHub repo
  CommitEd-project-service        <- Separate GitHub repo
  CommitEd-notification-service   <- Separate GitHub repo
  CommitEd-api-gateway            <- Separate GitHub repo

Each repo contains:
  src/
  tests/
  Dockerfile
  package.json
  .env.example
  README.md

Clone each service individually:
  git clone https://github.com/YourOrg/CommitEd-auth-service
  git clone https://github.com/YourOrg/CommitEd-user-service
  git clone https://github.com/YourOrg/CommitEd-project-service
  git clone https://github.com/YourOrg/CommitEd-notification-service
  git clone https://github.com/YourOrg/CommitEd-api-gateway

================================================================
  COMMITED-SPECIFIC GUIDES
================================================================

1. git/06-microservices-workflow.md - START HERE
   ├─ CommitEd's microservices architecture
   ├─ Services: auth, user, project, notification, api-gateway (EXAMPLES)
   ├─ Each service = separate GitHub repository
   ├─ Branch naming: feature/<service>/<description>
   ├─ Commit scopes: feat(auth), fix(user), docs(api)
   ├─ Running services locally with docker-compose
   ├─ Versioning each service independently
   ├─ Cross-service PR coordination
   └─ Deployment order for dependencies

2. github/08-issues-discussions.md - TASK MANAGEMENT
   ├─ GitHub Issues for work tracking
   ├─ Issue templates and best practices
   ├─ Service labels: auth-service, user-service, etc.
   ├─ GitHub Discussions for team conversations
   ├─ Converting discussions to issues
   ├─ Kanban board management
   ├─ Linking PRs to issues (auto-close)
   └─ CommitEd-specific examples

3. github/07-semantic-versioning.md - RELEASES
   ├─ What is semantic versioning (MAJOR.MINOR.PATCH)
   ├─ When to bump versions
   ├─ Tagging releases in Git
   ├─ Release notes and changelogs
   ├─ Versioning multiple services
   ├─ CHANGELOG.md format
   ├─ Release checklist
   └─ CommitEd version planning

================================================================
  YOUR BRANCH NAMING CONVENTION
================================================================

Format: <type>/<service>/<description>

Types:
  feature/  - New functionality
  fix/      - Bug fix
  docs/     - Documentation
  refactor/ - Code improvement
  test/     - Test addition

Services (EXAMPLES - use your real service names):
  auth      - Auth Service
  user      - User Service
  project   - Project Service
  notif     - Notification Service
  api       - API Gateway

Examples (REPLACE with your service names):
  feature/auth/two-factor-authentication
  fix/user/profile-image-validation
  docs/api/rate-limiting-docs
  refactor/project/database-queries
  feature/notif/email-queue

AVOID:
  feature/new-auth-stuff (no service)
  user-updates (vague, no type)
  fix-bug (no service name)

================================================================
  YOUR COMMIT MESSAGE CONVENTION
================================================================

Format: <type>(<service>): <description>

Services (EXAMPLES - use your real service names):
  auth, user, project, notif, api

Examples (REPLACE with your service names):
  feat(auth): add JWT token refresh endpoint
  fix(user): validate profile image size
  docs(api): update rate limiting documentation
  refactor(project): split database queries
  test(notif): add email template tests

Your convention shows:
  - What changed (feat, fix, docs, etc.)
  - Which service (auth, user, project, etc.)
  - What specifically (clear description)

================================================================
  YOUR ISSUE MANAGEMENT
================================================================

Create GitHub Issues for all work (in each service's repository):

Title Format:
  [TYPE] Service: Description

Types: FEATURE, BUG, TASK, DOCS, REFACTOR

Examples (EXAMPLES - use your real service names):
  [FEATURE] Auth: Add two-factor authentication
  [BUG] User Service: Avatar upload fails
  [TASK] API Gateway: Update rate limiting
  [DOCS] Project: Document sharing API

Labels (apply multiple):
  Type:     bug, feature, task, docs, refactor
  Priority: high-priority, blocked
  Service:  auth-service, user-service, project-service, notif-service, api-gateway
  Status:   in-progress, in-review

Workflow:
  1. Create issue with labels
  2. Assign to yourself
  3. Create branch: feature/<service>/<description>
  4. In PR, write "Closes #42" (links to issue)
  5. After merge, issue auto-closes

================================================================
  YOUR VERSIONING STRATEGY
================================================================

Each service has independent version (MAJOR.MINOR.PATCH):

Current Stage:
  0.x.y - Pre-release / Learning phase
  Goal:  1.0.0 - Production ready

Example Release (CommitEd v1.0.0) - EXAMPLE SERVICE NAMES:
  auth-service:            v1.0.0
  user-service:            v1.0.0
  project-service:         v1.0.0
  notification-service:    v1.0.0
  api-gateway:             v1.0.0

Release Checklist:
  [ ] Update version in each service's package.json
  [ ] Update CHANGELOG.md with all changes
  [ ] Test all services together locally
  [ ] Create release branch: release/v1.0.0
  [ ] Create PR to main
  [ ] Get review & approval
  [ ] Merge to main
  [ ] Tag: git tag -a v1.0.0 -m "Release message"
  [ ] Push tag: git push origin v1.0.0
  [ ] Create GitHub Release with notes

================================================================
  YOUR LOCAL DEVELOPMENT SETUP
================================================================

Quick Start:

1. Clone each service (example names):
   git clone https://github.com/YourOrg/CommitEd-auth-service
   git clone https://github.com/YourOrg/CommitEd-user-service
   git clone https://github.com/YourOrg/CommitEd-project-service
   git clone https://github.com/YourOrg/CommitEd-notification-service
   git clone https://github.com/YourOrg/CommitEd-api-gateway

2. Create docker-compose.yml in parent directory and start:
   docker-compose up

3. Services available at (example ports):
   http://localhost:3000      API Gateway
   http://localhost:3001      Auth Service
   http://localhost:3002      User Service
   http://localhost:3003      Project Service
   http://localhost:3004      Notification Service

4. Test everything works:
   curl http://localhost:3000/health

================================================================
  YOUR DAILY WORKFLOW FOR COMMITED
================================================================

Morning (Sync with team):
  1. (In your service repo) git checkout dev
  2. git pull origin dev
  3. docker-compose up (start all services from parent directory)
  4. Check GitHub issues for assigned tasks

Pick a task:
  1. Find issue on GitHub (e.g., #42)
  2. Create branch: feature/user/profile-image (EXAMPLE)
  3. git checkout feature/user/profile-image

Work:
  1. Make changes in your service repository
  2. Test locally: services already running in docker-compose
  3. Make regular commits: feat(user): add image upload (EXAMPLE)
  4. git push origin feature/user/profile-image

Create PR:
  1. Go to GitHub (in your service's repository)
  2. Click "Create Pull Request"
  3. Base: dev, Compare: feature/user/profile-image
  4. Title: [FEATURE] User: Add profile image upload (EXAMPLE)
  5. Description: What, why, testing steps
  6. Link issue: "Closes #42"
  7. Request review from teammate

Review Process:
  1. Teammate reviews code
  2. If requested changes: make them, push again
  3. When approved: merge to dev
  4. Delete your branch

================================================================
  GUIDE READING PATH FOR COMMITED
================================================================

BEFORE FIRST SPRINT:
  1. README.md (15 min)
  2. git/01-basics.md (15 min)
  3. git/06-microservices-workflow.md (25 min)
  4. github/01-collaboration-basics.md (20 min)
  5. github/08-issues-discussions.md (20 min)
  6. scrum/01-overview.md (20 min)

BEFORE MAKING FIRST PR:
  7. github/02-pull-requests.md (20 min)
  8. github/06-quick-reference.md (10 min)

BEFORE FIRST RELEASE:
  9. github/07-semantic-versioning.md (20 min)

================================================================
  TOOLS FOR COMMITED TEAM
================================================================

Version Control:  Git (distributed)
Repository:       GitHub (CommitEd organization)
Collaboration:    GitHub Issues, Discussions, PRs
Communication:    Slack/Discord, Standups
Database:         PostgreSQL (per service)
Containerization: Docker
Orchestration:    Docker Compose (local), Kubernetes (production later)
CI/CD:            GitHub Actions
Documentation:    Typst, Markdown

================================================================
  WHAT MAKES COMMITED DIFFERENT
================================================================

Microservices Architecture
  Each service independent, separate repo, own database, own version

Service-Specific Naming
  Branches, commits, issues all include service name (example names provided)

Independent Versioning
  Each service versioned separately (example)

Clear Coordination
  Cross-service PRs documented, deployment order clear

Professional Practices
  Semantic versioning, changelogs, release notes

Team Communication
  GitHub Issues for work, Discussions for decisions

================================================================
  SUCCESS CRITERIA
================================================================

After first sprint:
  All team members can start services locally
  Created issues on GitHub
  Made PR with service-specific naming
  Understand microservices structure
  Know your service's role

After third sprint:
  100+ commits across services
  Complex features merged across services
  Comfortable with cross-service coordination
  Clear versioning strategy
  Ready for production release

End of project:
  CommitEd v1.0.0 deployed
  All services stable
  Professional documentation
  Team ready for real jobs
  Portfolio-worthy project

================================================================

BOOKMARK THESE:
  git/06-microservices-workflow.md (CommitEd structure)
  github/08-issues-discussions.md (task management)
  github/06-quick-reference.md (daily use)
  github/07-semantic-versioning.md (releases)

START WITH:
  git/06-microservices-workflow.md

================================================================

Good luck building CommitEd!

You're learning real software engineering used by professional companies.
These practices will be valuable in your career.

REMEMBER: Service names in guides are EXAMPLES. Replace them with your
actual service names from your architecture.

================================================================
